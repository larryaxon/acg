using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

using ACG.Common;

namespace TAGBOSS.Common.Model
{
  /// <summary>
  /// The Item class. This is a collection of Attributes.
  /// </summary>
  [SerializableAttribute]
  public class Item : DataClass<TAGAttribute>
  {
    #region constants
    public const string EXPIRED = "Expired";
    public const string INHERITED = "Inherited";
    public const string CURRENT = "Current";
    public const string BLOCKED = "Blocked";
    public const string GENERATED = "Generated";
    public const string HISTORY = "History";
    public const string MERGED = "Merged";
    public const string ENTERED = "Entered";
    public const string IMPORTED = "Imported";
    public const string AUTOPAY = "AutoPay";
    public const string CALCULATED = "Calculated";
    public const string ENTRY = "Entry";
    public const string REVIEW = "Review";
    public const string INVALID = "Invalid";   //This will be used to tag invalid items, for example nonexisting ones in the cache...
    public const string VOID = "Void";
    public const string VOIDENTERED = "VoidEntered";

    public const string ATTRIBUTESTATUSEVENT = "StatusEvent";
    public const string ATTRIBUTESTATUSEVENTMASTERLIST = "StatusEventMasterList";
    #endregion  

    #region module data
    private DateTime startDate = TAGFunctions.PastDateTime;
    private DateTime endDate = TAGFunctions.FutureDateTime;
    private string source = string.Empty;
    private string uniqueID = null;
    private bool isInherited = false;
    //private bool isActive = true;
    //TODO: Change this to properties...

    //private string inheritedFrom = null;
    private string lastModifiedBy = string.Empty;
    private DateTime lastModifiedDateTime = DateTime.Now;
    private string thisUser= string.Empty;
    private ItemHistoryCollection itemHistories = new ItemHistoryCollection();
    private DateTime effectiveDate = DateTime.Now;
    SortedDictionary<string, SortedDictionary<string, TAGAttribute>> valueTypeIndex = new SortedDictionary<string, SortedDictionary<string, TAGAttribute>>();
    IncludedItemTree includedItemTree = new IncludedItemTree();

    #endregion module data

    #region constructor
    public Item(string json)
      : base()
    {
      startDate = TAGFunctions.PastDateTime;       // default value for StartDate is a date arbitrarily far in the past
      endDate = TAGFunctions.FutureDateTime;       // default value for EndDate is a date arbitrarily far in the future
      //thisUser = TAGFunctions.User;
      itemHistories.ID = "ih";                      // we need at least a dummy value in itemHistories, since it implements IDataClassContainer
                                                  // and some routines do not like this to be null
      loadJson(json);
    }
    /// <summary>
    /// Constructor just sets up a default value for start and end dates
    /// </summary>
    public Item(): base()
    {
      startDate = TAGFunctions.PastDateTime;       // default value for StartDate is a date arbitrarily far in the past
      endDate = TAGFunctions.FutureDateTime;       // default value for EndDate is a date arbitrarily far in the future
      //thisUser = TAGFunctions.User;
      itemHistories.ID = "ih";                      // we need at least a dummy value in itemHistories, since it implements IDataClassContainer
                                                    // and some routines do not like this to be null
    }
    #endregion

    #region static constants and methods
    ///// <summary>
    ///// This Item is Calculated
    ///// </summary>
    //public static string CALCULATED
    //{
    //  get { return cCALCULATED; }
    //}
    ///// <summary>
    ///// This item was Imported
    ///// </summary>
    //public static string IMPORTED
    //{
    //  get { return cIMPORTED; }
    //}

    ///// <summary>
    ///// This item was generated by AutoPay
    ///// </summary>
    //public static string AUTOPAY
    //{
    //  get { return cAUTOPAY; }
    //}

    ///// <summary>
    ///// This transCode was entered!
    ///// </summary>
    //public static string ENTERED
    //{
    //  get { return cENTERED; }
    //}

    ///// <summary>
    ///// This transCode has expired!
    ///// </summary>
    //public static string EXPIRED 
    //{
    //  get { return cEXPIRED;}
    //}

    ///// <summary>
    ///// This transCode is Inherited!
    ///// </summary>
    //public static string INHERITED 
    //{
    //  get { return cINHERITED;}
    //}

    ///// <summary>
    ///// This transCode is Current!
    ///// </summary>
    //public static string CURRENT 
    //{
    //  get { return cCURRENT;}
    //}

    ///// <summary>
    ///// this Item is Blocked
    ///// </summary>
    //public static string BLOCKED
    //{
    //  get { return cBLOCKED; }
    //}

    ///// <summary>
    ///// This transCode was Generated!
    ///// </summary>
    //public static string GENERATED
    //{
    //  get { return cGENERATED;}
    //}

    ///// <summary>
    ///// This transCode is History!
    ///// </summary>
    //public static string HISTORY
    //{
    //  get { return cHISTORY; }
    //}

    ///// <summary>
    ///// This transCode is Merged!
    ///// </summary>
    //public static string MERGED
    //{
    //  get { return cMERGED; }
    //}

    ///// <summary>
    ///// This is an INVALID item!
    ///// </summary>
    //public static string INVALID
    //{
    //  get { return cINVALID; }
    //}

    ///// <summary>
    ///// This trans is Voided!
    ///// </summary>
    //public static string VOID
    //{
    //  get { return cVOID; }
    //}

    ///// <summary>
    ///// This trans is Voided!
    ///// </summary>
    //public static string VOIDENTERED
    //{
    //  get { return cVOIDENTERED; }
    //}
    /// <summary>
    /// Based on the source, is this record in an Entered status?
    /// </summary>
    /// <param name="source"></param>
    /// <returns></returns>
    public static bool IsEntered(string source)
    {
      if (source == null)
        return false;
      return (source.Equals(ENTERED, StringComparison.CurrentCultureIgnoreCase) || source.Equals(AUTOPAY, StringComparison.CurrentCultureIgnoreCase) ||
        source.Equals(IMPORTED, StringComparison.CurrentCultureIgnoreCase) || source.Equals(VOID, StringComparison.CurrentCultureIgnoreCase) ||
        source.Equals(VOIDENTERED, StringComparison.CurrentCultureIgnoreCase));
      //string sourceCompare = source.ToLower();
      //return (sourceCompare == Item.ENTERED.ToLower() || sourceCompare == Item.AUTOPAY.ToLower() 
      //  || sourceCompare == Item.IMPORTED.ToLower() || sourceCompare == Item.VOID.ToLower() || sourceCompare == Item.VOIDENTERED.ToLower());
    }
    #endregion

    #region public properties

    public byte Depth { get; set; }
    //public new Dictionaries Dictionary 
    //{
    //  get { return base.Dictionary; }
    //  set
    //  {
    //    if (itemHistories.Dictionary == null || value == null)
    //      itemHistories.Dictionary = null;
    //    base.Dictionary = value;
    //  }
    //}
    /// <summary>
    /// Overload of DataClass.Description that returns the value of the Description attribute if there is one
    /// </summary>
    public new string Description
    {
      get
      {
        if (Attributes.Contains("Description"))
        {
          string desc = (string)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.CString, Attributes["Description"].Value);
          if (desc == string.Empty)
            return base.Description;
          else
            return desc;
        }
        else
          return base.Description;
      }
      set { base.Description = value; }
    }
    /// <summary>
    /// 
    /// </summary>
    public string Source
    {
      get { return source; }
      set 
      {
        source = value;
        //if (source == Item.GENERATED)
        //  foreach (TAGAttribute i_attr in this.Attributes)
        //    i_attr.IsGenerated = true;
        //else if (source == Item.HISTORY)
        //  foreach (TAGAttribute i_attr in this.Attributes)
        //    i_attr.IsHistory = true;
      }
    }
    
    /// <summary>
    /// 
    /// </summary>
    public string CurrentUser
    {
      get { return thisUser; }
      set { thisUser = value; }
    }

    /// <summary>
    /// If this item was loaded from TransDetail or some other source with attributes instead
    /// of from the Attribute table, then this is where we store the database unique id
    /// (e.g. TransDetailID).
    /// </summary>
    public string UniqueID
    {
      get { return uniqueID; }
      set { uniqueID = value; }
    }

    //TODO: Manage the Item's ItemHistory collection
    /*
     * 1) whatever the effectivedate of the item call, only the item history that includes that effectivedate can be edited.
     * 2) no overlapps are allowed
     * 3) if there is no itemhistory, you need to create one
     *itemHistory  cases:
     * StartDate     EndDate
     * None           1/1/2009
     * 1/31/2009  4/15/2009
     * 6/1/2009    None
     * 
     */
    /// <summary>
    /// The Item StartDate (not to be confused with the TAGAttribute/Value History StartDate).
    /// </summary>
    public DateTime StartDate
    {
      get { return startDate; }
      set
      {
        DateTime myStartDate = Convert.ToDateTime(value.ToString("d"));     // truncate time portion before storing and validation
        if (itemHistories.Count == 0)
        {
          ItemHistory itemHstNew = new ItemHistory();
          itemHstNew.StartDate = myStartDate;
          itemHstNew.EndDate = TAGFunctions.FutureDateTime;
          itemHistories.Add(itemHstNew);
        }
        else 
        {
          ItemHistory itemHstActive = null;
          foreach (ItemHistory itemHst in itemHistories) 
          {
            if (itemHst.StartDate <= effectiveDate && effectiveDate <= itemHst.EndDate)
            {
              itemHstActive = itemHst;
              break;
            }
          }
          if (itemHstActive != null)
          {
            //We have a valid interval, now let's see if the passed value is in between it, so we can change the startdate of the interval
            if (itemHstActive.StartDate <= myStartDate && myStartDate <= itemHstActive.EndDate) 
            { //So we have a valid range, and the passed value is in between, so we accept the value and change the startDate of the interval to the one passed
              itemHstActive.StartDate = myStartDate;
              startDate = myStartDate;
            }
          }
          else 
          {
            // In this case we do not set anything! there is not a valid itemHistory interval
            // so we do not assign any value to the startDate...
          }
        }
      }    
    }

    /// <summary>
    /// The Item EndDate (not to be confused with the TAGAttribute/Value History EndDate)
    /// </summary>
    public DateTime EndDate
    {
      get { return endDate; }
      set
      {
        DateTime myEndDate = Convert.ToDateTime(value.ToString("d"));     // truncate time portion before storing and validation
        if (itemHistories.Count == 0)
        {
          ItemHistory itemHstNew = new ItemHistory();
          itemHstNew.StartDate = TAGFunctions.PastDateTime;
          itemHstNew.EndDate = myEndDate;
          itemHistories.Add(itemHstNew);
        }
        else
        {
          foreach (ItemHistory ih in itemHistories)
          {
            if (ih.EndDate == endDate || ih.EndDate == TAGFunctions.FutureDateTime)    // is this the last date history record or the one that caused the current value of Item.EndDate to be set?
            {
              ih.EndDate = myEndDate;
              break;
            }
          }
        }
        endDate = myEndDate;  /// in any case, set the item end date
      }
    }

    /// <summary>
    /// The effective Date that was used to select this item
    /// </summary>
    public DateTime EffectiveDate
    {
      get { return effectiveDate; }
      set { effectiveDate = value; }
    }
    /// <summary>
    /// The collection of Attributes for this item (basically renames "this" for convenience of syntax
    /// </summary>
    public Item Attributes
    {
      get { return this; }
    }
    /// <summary>
    /// exposes or sets the ItemHistory
    /// </summary>
    public ItemHistoryCollection ItemHistoryRecords
    {
      get { return itemHistories; }
      set { itemHistories = value; }
    }

    /// <summary>
    /// If all of the item's history is included, this flag indicates whether this current item, of all
    /// of the items with the same id/key, is the one that matches the effectivedate. True
    /// means it is. So, if you do not want history, then just make sure and get only items with
    /// Active = true.
    /// </summary>
    //public bool Active
    //{
    //  get { return isActive; }
    //  set { isActive = value; }
    //}
    /// <summary>
    /// Was this item inherited from above in the inheritance chain?
    /// </summary>
    public bool IsInherited
    {
      get { return isInherited; }
      set { isInherited = value; }
    }

    /// <summary>
    /// Not currently implemented. If it is, it will be the EntityID from which this
    /// Item was inherited if it is not in the lowest level Entity in the inheritance
    /// chain.
    /// </summary>
    //public string InheritedFrom
    //{
    //    get { return inheritedFrom; }
    //    set { inheritedFrom = value; }
    //}
    /// <summary>
    /// Override of DataClass.Dirty which sets the last modified date and id if the record is flagged as dirty
    /// </summary>
    new public bool Dirty
    {
      get { return (itemHistories.Dirty || base.Dirty); } // Return dirty if either base (Includes attributes) or itemHistory is dirty
      set
      {
        base.Dirty = value;
        if (!value)
          itemHistories.Dirty = value;
        if (base.Dirty)
        {
          lastModifiedDateTime = DateTime.Now;
          lastModifiedBy = thisUser;
        }
      }
    }
    /// <summary>
    /// The Entity id of the last user to modify this record
    /// </summary>
    public string LastModifiedBy
    {
      get { return lastModifiedBy; }
      set { lastModifiedBy = value; }
    }
    /// <summary>
    /// The date/time stamp of the last time this record was modified
    /// </summary>
    public DateTime LastModifiedDateTime
    {
      get { return lastModifiedDateTime; }
      set { lastModifiedDateTime = value; }
    }

    /// <summary>
    /// IncludedItemTree, is a SortedList of all the items that directly or indirectly inherit attributes to this item!
    /// </summary>
    public IncludedItemTree IncludedItemTree
    {
      get { return includedItemTree; }
      set { includedItemTree = value; }
    }
    #endregion public properties

    #region public methods

    /// <summary>
    /// easy way to get a value of an attribute, without having to check if the attribute exists
    /// </summary>
    /// <param name="attributeName">Name of the attribute we want</param>
    /// <returns>Attriute.Value if it exists, otherwise null</returns>
    public object getValue(string attributeName)
    {
      if (Contains(attributeName))
        return this[attributeName].Value;
      else
        return null;
    }
    
    /// <summary>
    /// Set the value of an attribute using the specific data type
    /// </summary>
    /// <param name="attributeName"></param>
    /// <param name="value"></param>
    /// <param name="dataType"></param>
    public void setValue(string attributeName, object value, string dataType)
    {
      object newValue;
      if (dataType == null)
        newValue = value;
      else
        newValue = TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.toValue, value, dataType);
      if (Attributes.Contains(attributeName))
        Attributes[attributeName].setValue(newValue, dataType);
    }

    /// <summary>
    /// Creates a copy of this item into a new item object, it copies all the properties of the item into the new cloned item
    /// </summary>
    /// <returns></returns>
    public new object Clone()
    {
      Item i = new Item();
     
      //i = (Item)base.Clone<Item>(i);
      // We needed to replace the base clone logic because we need for our overloade Add() method to add attributes, not the base Add() method. Larry

      foreach (string key in items)   // for each unique key
      {
        TAGAttribute a = (TAGAttribute)itemHash[key].Clone();
        i.Add(a);
        //Dictionary<int, TAGAttribute> entry = itemHash[key];   // get the history for that key
        //for (int k = entry.Count - 1; k >= 0; k--)  // start with oldest to newest, and add them. This is because add will assume new ones coming in are more current than old ones
        //{
        //  TAGAttribute a = entry[k];
        //  i.Add(a);
        //}
      }
      i.Deleted = Deleted;
      i.Dirty = Dirty;
      i.MarkForDelete = MarkForDelete;
      /*
       * Although 99% of the time, a DataClass is both an item in a larger collection, and 
       * a collection itself, sometimes (like in the EntitiesCollection of the EntityAttributesCollection
       * class), it is just a collection. If it is not an item in another collection, there
       * may be no ID to clone. If this ID is null, and we try to clone it, we get an error
       * since the ID property does a .ToLower(). So, we check first, and don't try
       * to clone it if it is null
       */
      if (OriginalID != null)
        i.ID = OriginalID;                    // copy the original id to ID. there will be two copies made, one lowercased for the key, the other the original
      else
        if (ID != null)
          i.ID = ID;                      // copy the regular id
      // else                           // ok, so ID is not instantiated, don't copy it.
      i.Description = Description;

      i.ItemHistoryRecords = (ItemHistoryCollection)itemHistories.Clone();
      i.LastModifiedBy = LastModifiedBy;
      i.LastModifiedDateTime = LastModifiedDateTime;
      i.CurrentUser = CurrentUser;
      // LLA 9/1/2009: We have already cloned the item history so we don't clone these virtual fields
      //i.StartDate = startDate;
      //i.EndDate = endDate;
      i.Source = source;
      i.UniqueID = uniqueID;
      i.CurrentUser = thisUser;
      i.EffectiveDate = effectiveDate;
      i.Depth = Depth;
      return i;
    }
    
    /// <summary>
    /// Add an TAGAttribute to the Item based on just the ID and Value
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    public void AddAttribute(string pID, object pValue)             // Adds a entry from just the ID and the Value without
    {                                                               // requiring the calling program to create a TAGAttribute object
      TAGAttribute a = new TAGAttribute();
      a.ID = pID;
      a.Value = pValue;
      Add(a);
    }
    //lmv66 2008 0519 BEGIN: three overloads for AddAttribute, so it can support somehow a "parent" option...
    
    /*
    /// <summary>
    /// Add an TAGAttribute to the Item based on ID, Value, DataType, and ValueType
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    /// <param name="dataType"></param>
    /// <param name="valueType"></param>

    public void AddAttribute(string pID, object pValue, string dataType, string valueType)
    {
        TAGAttribute a = new TAGAttribute();
        a.ID = pID;
        a.Value = pValue;
        a.DataType = dataType;
        a.ValueType = valueType;
        Add(a);
    }            
    */
    /// <summary>
    /// Add an TAGAttribute to the Item based on ID, Value, and DataType
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    /// <param name="dataType"></param>
    public void AddAttribute(string pID, object pValue, string dataType)
    {
      TAGAttribute a = new TAGAttribute();
      a.ID = pID;
      a.Value = pValue;
      a.DataType = dataType;
      Add(a);
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    /// <param name="parent"></param>
    public void AddAttribute(string pID, object pValue, Item parent)             // Adds a entry from just the ID and the Value without
    {                                                               // requiring the calling program to create a TAGAttribute object
      TAGAttribute a = new TAGAttribute();
      a.ID = pID;
      a.Value = pValue;
      a.Parent = parent;

      Add(a);
    }

    /*
    /// <summary>
    /// 
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    /// <param name="dataType"></param>
    /// <param name="valueType"></param>
    /// <param name="parent"></param>
    public void AddAttribute(string pID, object pValue, string dataType, string valueType, Item parent)
    {
        TAGAttribute a = new TAGAttribute();
        a.ID = pID;
        a.Value = pValue;
        a.DataType = dataType;
        a.ValueType = valueType;
        a.Parent = parent;

        Add(a);
    }
    */
    /// <summary>
    /// 
    /// </summary>
    /// <param name="pID"></param>
    /// <param name="pValue"></param>
    /// <param name="dataType"></param>
    /// <param name="parent"></param>
    public void AddAttribute(string pID, object pValue, string dataType, Item parent)
    {
      TAGAttribute a = new TAGAttribute();
      a.ID = pID;
      a.Value = pValue;
      a.DataType = dataType;
      a.Parent = parent;

      Add(a);
    }

    //lmv66 2008 0519 END: three overloads for AddAttribute, so it can support somehow a "parent" option...
    public new void Add(string aID, TAGAttribute a)
    {
      base.Add(aID, a);
      //if (a.ValueType.ToLower() != "value")
      addValueTypeAttribute(a);
    }
    public new void Add(TAGAttribute a)
    {
      Add(a.OriginalID, a);
    }
    public new void Remove(string attributeID)
    {
      if (!MarkForDelete && Contains(attributeID))
        removeValueTypeAttribute(this[attributeID]);
      base.Remove(attributeID);
    }
    public void setValueType(string attributeID, string newValueType)
    {
      if (Contains(attributeID))
      {
        TAGAttribute a = this[attributeID];
        removeValueTypeAttribute(a);
        a.ValueType = newValueType;
        addValueTypeAttribute(a);
      }
    }

    public string[] AttributeIDByValueType(string pValueType)
    {
      if (pValueType == null || !valueTypeIndex.ContainsKey(pValueType))
        return new string[0];
      string[] attributeList = new string[valueTypeIndex[pValueType].Count];
      for (int i = 0; i < valueTypeIndex[pValueType].Count; i++)
        attributeList[i] = valueTypeIndex[pValueType].ElementAt(i).Value.OriginalID;
      return attributeList;
    }

    public TAGAttribute foreachValueType(string pValueType, ref int seedIndex)
    {
      if (pValueType == null || !valueTypeIndex.ContainsKey(pValueType) || seedIndex < 0 || seedIndex >= valueTypeIndex[pValueType].Count)
      {
        seedIndex = -1;
        return null;
      }
      //TODO: Review this fix! we get the Key from the collection! and then return the TAGAttribute from the Attributes collection!
      //We need to check this with Larry and change the itemTypes collections...
      string attrKey = valueTypeIndex[pValueType].ElementAt(seedIndex++).Key;
      return Attributes[attrKey];
    }

    /// <summary>
    /// Loads the Item History XML from the ItemHistory collection
    /// </summary>
    /// <returns></returns>
    public string ToItemHistoryXML()
    {
      // TODO lmv66 create this xml from the ItemHistory collection
      string itemHistoryXML = "<ItemDates>";
      foreach (ItemHistory iH in this.itemHistories)
      {
        string startDate = string.Empty;
        string endDate = string.Empty;

        itemHistoryXML += "<ItemHistory ";
        if (iH.StartDate > TAGFunctions.PastDateTime)
          startDate = " startdate=\"" + iH.StartDate.ToShortDateString() + "\"";
        if (iH.EndDate < TAGFunctions.FutureDateTime)
          endDate = " enddate=\"" + iH.EndDate.ToShortDateString() + "\"";
        itemHistoryXML += startDate + endDate + "/>";
      }
      itemHistoryXML += "</ItemDates>";

      return itemHistoryXML;
    }
    
    /// <summary>
    /// Returns the ItemHistory Collection
    /// </summary>
    /// <param name="strAttributes"></param>
    /// <param name="effectiveDate"></param>
    /// <param name="rawMode"></param>
    /// <returns></returns>
    public ItemHistoryCollection ToItemHistories(string strItemHistory)
    {
      ItemHistoryCollection iHC = new ItemHistoryCollection();

      XmlDocument xmlItemHistoryInput = new XmlDocument();
      xmlItemHistoryInput.LoadXml(strItemHistory);

      XmlNodeList xmlItemHistories = xmlItemHistoryInput.SelectNodes("//ItemDates/*");
      if (xmlItemHistories.Count > 1)
      {
        int i = 1;
      }
      foreach (XmlNode xmlItemHistory in xmlItemHistories)
      {
        DateTime attrStartDate = TAGFunctions.PastDateTime;
        DateTime attrEndDate = TAGFunctions.FutureDateTime;

        ItemHistory iH = new ItemHistory();
        foreach (XmlAttribute xmlValueHistoryAttr in xmlItemHistory.Attributes)
        {
          switch (xmlValueHistoryAttr.Name)
          {
            case "startdate":
              attrStartDate = global::System.Convert.ToDateTime(xmlValueHistoryAttr.Value.ToString());
              break;
            case "enddate":
              attrEndDate = global::System.Convert.ToDateTime(xmlValueHistoryAttr.Value.ToString());
              break;
          }

        }
        iH.StartDate = attrStartDate;
        iH.EndDate = attrEndDate;
        if (iH.StartDate <= effectiveDate && iH.EndDate >= effectiveDate)
        {
          startDate = iH.StartDate;
          endDate = iH.EndDate;
        }
        iHC.Add(iH);
      }
      return iHC;

    }
    
    /// <summary>
    /// Takes the current Item Instance and reconverts it back to the e_Attribute XML format.
    /// Note this version only includes dirty attributes because it is called by the Save
    /// method
    /// </summary>
    /// <param name="oldXML">Copy of XML before the edit, so they can be merged</param>
    /// <returns>An e_Attribute Attributes XML string format of the item, optionally only including </returns>
    public string ToXML(string oldXML)
    {
      return ToXML(oldXML, false);
    }

    /// <summary>
    /// Overload that allows the calling program to request ALL attributes, not just dirty ones
    /// </summary>
    /// <param name="oldXML"></param>
    /// <param name="includeCleanAttributes"></param>
    /// <returns></returns>
    public string ToXML(string oldXML, bool includeCleanAttributes)
    {
      /*
       * 1) start with the old XML. You will need to retrieve this from the table. We do this in case
       *      someone has updated it since we retrieved it last
       *      NOTE: if someone has added an attribute since we retrieved it, we will pick it up.
       *      However, if they have updated an attribute, we will overwrite it.
       * 2) Add new Attributes (dirty == true and node does not exist in old XML)
       * 3) Update Attributes (dirty == true and node does exist in old XML)
       *      Note: Calling program is responsible for managing Values collection. Just delete the old TAGAttribute
       *      node with its values collection and replace with the new one
       * 4) Deleted. Deleted records are the same as updates in valuehistory, because they are flagged already
       *     in the valuehistory as deleted with end date one day before the start date: 
       *     
       * 9/18/2008 LLA: Added logic to ignore attributes if their ReadOnly flag is set
       * TODO: Need to create an XML schema for the Attributes data and validate against that.
       * Where should this validation take place?
       * 
       * 6/9/2011 LLA: We have this one condition that we have not handled properly. It is:
       * 1) inherited load of the item for item maintenance had an effectivedate that matched a "hole" in
       *    at least one attribute value history. e.g. effective date after last end date, or between the
       *    end date of one value history and the start date of the next.
       * 2) The attribute therefore is NOT included in the result set, per current specifications
       * 3) The user enters a value for that attribute and saves it. That creates exactly one new value history with
       *    a start date of the effectivedate and and enddate of TAGFunctions.FutureDateTime
       * 4) In this case, the old xml has valid history we need to merge with the new history record. We need to:
       *    a) find the "hole" in the old value history
       *    b) find the next value history AFTER the new one in the hole
       *    c) change the end date of the new one to one day before the start date of the next old on
       *    d) merge the history
       * So, to do this, we load the old xml into an item so we can search and find the conflict and merge it.
       * Note: we only do this if we need to, so we start with a null OldItem and ItemType object (needed to
       * run the AttributesColection() import of xml to Item) and only instantiate them if we have an attribute
       * that meets the requirements (just one vh with start date of effectivedate)
       */
      Item oldItem = null;
      ItemType blankItemType = null;
      XmlDocument myXMLDoc = new XmlDocument(); 
      if (oldXML == "")
        oldXML = "<attributes></attributes>";

      myXMLDoc.LoadXml(oldXML);
      foreach (TAGAttribute a in this)
      {
        if (a.Deleted)
        {
          // first, we delete this from the old xml if it exists
          XmlNode aOld = myXMLDoc.SelectSingleNode(string.Format("//attributes/attribute[@name = '{0}']", a.OriginalID));
          if (aOld != null) // it is in the old xml (if not, we don't do anything cause it is already deleted
          {
            XmlNodeList aOldValueHistories
              = aOld.SelectNodes(string.Format("./valuehistory", a.ID));
            if (aOldValueHistories != null) // if it has value history (otherwise we do nothing, since a value is not there to delete
            {
              for (int i = aOldValueHistories.Count - 1; i >= 0; i--) // look for the value history that matches the effective date
              {
                XmlNode xmlValueHistory = aOldValueHistories[i];
                DateTime attrStartDate = TAGFunctions.PastDateTime;
                DateTime attrEndDate = TAGFunctions.FutureDateTime;
                foreach (XmlAttribute xmlValueHistoryAttr in xmlValueHistory.Attributes)  // pick up the start and end dates
                {
                  switch (xmlValueHistoryAttr.Name.ToLower())
                  {
                    case TAGFunctions.STARTDATE:
                      attrStartDate = (DateTime)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.CDateTime, xmlValueHistory.Attributes[TAGFunctions.STARTDATE].Value, TAGFunctions.PastDateTime);
                      break;
                    case TAGFunctions.ENDDATE:
                      attrStartDate = (DateTime)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.CDateTime, xmlValueHistory.Attributes[TAGFunctions.ENDDATE].Value, TAGFunctions.FutureDateTime);
                      break;
                  }
                }
                // if this vh matches the effective date
                if (attrStartDate <= effectiveDate && effectiveDate <= attrEndDate)
                {
                  // then terminate the vh by setting the end date to the day before the effective date
                  XmlAttribute xmlEndDate = xmlValueHistory.Attributes[TAGFunctions.ENDDATE];
                  if (xmlEndDate == null) // there was no end date attribute
                  {
                    xmlEndDate = myXMLDoc.CreateAttribute("enddate");
                    xmlValueHistory.Attributes.Append(xmlEndDate);
                  }
                  xmlValueHistory.Attributes[TAGFunctions.ENDDATE].Value = effectiveDate.AddDays(-1).ToShortDateString();
                  // and record who did this and when
                  XmlAttribute xmlLastModifiedBy = xmlValueHistory.Attributes[TAGFunctions.LASTMODIFIEDBY];
                  if (xmlLastModifiedBy != null)
                    xmlLastModifiedBy.Value = lastModifiedBy;
                  XmlAttribute xmlLastModifiedDateTime = xmlValueHistory.Attributes[TAGFunctions.LASTMODIFIEDDATETIME];
                  if (xmlLastModifiedDateTime != null)
                    xmlLastModifiedDateTime.Value = DateTime.Now.ToString();
                  break;
                }
                // note: if we don't find a match on the effective date, then there are no current vh records to terminate, so we do nothing
              }
            }
            //// first get the root node (attributes)
            //XmlNode aRoot = myXMLDoc.SelectSingleNode("//attributes");
            //// then delete this attribute from that node if it exists
            //if (aRoot != null)
            //  aRoot.RemoveChild(aOld);
          }
          // 
        }
        else
        {
          if ((a.Dirty && !a.ReadOnly) || includeCleanAttributes)   // has this TAGAttribute been changed (LLA: and is not readonly)?
          {
            string aID = a.OriginalID;  //name of the TAGAttribute
            XmlNode aOld = myXMLDoc.SelectSingleNode(string.Format("//attributes/attribute[@name = '{0}']", aID));
            if (aOld != null)     //The attribute exists, so we just recreate the valuehistory!
            {
            // now test for our new "merge" condition
              if (a.Values.Count == 1 && a.Values[0].StartDate.Equals(a.EffectiveDate))
              {
                if (oldItem == null)  // load the item if we have not already done so
                {
                  blankItemType = new ItemType();
                  oldItem = blankItemType.AttributesCollection(oldXML, null, true);
                }
                if (oldItem.Attributes.Contains(aID))
                {
                  TAGAttribute oldAttribute = oldItem.Attributes[aID];
                  if (oldAttribute.Values.Count > 0)
                  {
                    // now we merge the histories
                    ValueHistory vhNew = a.Values[0]; // we've already established that there is exactly one
                    DateTime newStartdate = vhNew.StartDate;
                    bool holeFound = false;
                    DateTime holeEndDate = TAGFunctions.FutureDateTime.AddDays(-1);
                    oldAttribute.Values.Sort(true); // sort the old history newest date first
                    foreach (ValueHistory vhOld in oldAttribute.Values)
                    {

                      if (vhOld.EndDate < newStartdate && newStartdate < holeEndDate) // is this the "hole"?
                      {
                        vhNew.EndDate = holeEndDate;  // terminate the new vh with the last date in the hole
                        holeFound = true;
                        break;
                      }
                      else
                        if (newStartdate >= vhOld.StartDate) // we will not find a hole, cause we are now looking at older histories than the new record
                          break;
                        else
                          holeEndDate = vhOld.StartDate.AddDays(-1);
                    }
                    if (holeFound)
                    {
                      // now add all of the old history "around" the new history 
                      oldAttribute.Values.Sort(); // resort from lower to higher dates
                      foreach (ValueHistory vhOld in oldAttribute.Values)
                        a.Values.Add(vhOld);
                    }
                  }
                }
              }
              //aOld.InnerXml = "";   //We get rid of the existing valuehistories
              XmlNodeList aOldValueHistories
                  = myXMLDoc.SelectNodes(string.Format("//attributes/attribute[@name = '{0}']/valuehistory", aID));
              if (aOldValueHistories != null)
                for (int i = aOldValueHistories.Count - 1; i >= 0; i--)
                {
                  XmlNode aOldValueRange = aOldValueHistories[i];
                  aOld.RemoveChild(aOldValueRange);
                }
            }
            else
            {
              XmlNode myAttributes = myXMLDoc.SelectSingleNode("//attributes");
              myAttributes.InnerXml += string.Format("<attribute name='{0}'></attribute>", aID);
              aOld = myXMLDoc.SelectSingleNode(string.Format("//attributes/attribute[@name = '{0}']", aID));
            }

            string newVHs = "";
            foreach (ValueHistory aVH in a.Values)
            {
              string startDate = string.Empty;
              string endDate = string.Empty;
              string lastModifiedBy = string.Empty;
              string vType = aVH.ValueType;
              if (vType == null || vType == string.Empty)
                vType = "value";
              if (aVH.LastModifiedBy != null)
                lastModifiedBy = " lastmodifiedby=\"" + aVH.LastModifiedBy.Trim() + "\"";
              string lastModifiedDateTime = " lastmodifieddatetime=\""
                  + aVH.LastModifiedDateTime.ToString().Trim() + "\"";

              if (aVH.StartDate > TAGFunctions.PastDateTime)
                startDate = " startdate=\"" + aVH.StartDate.ToShortDateString() + "\"";
              if (aVH.EndDate < TAGFunctions.FutureDateTime)
                endDate = " enddate=\"" + aVH.EndDate.ToShortDateString() + "\"";
              newVHs += string.Format("<valuehistory {0}=\"{1}\"{2}{3}{4}{5}/>"
                  , vType, (string)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.toValidXMLString, aVH.Value, true), startDate, endDate, lastModifiedBy, lastModifiedDateTime);
            }
            if (newVHs != string.Empty)
            {
              newVHs = newVHs.Replace("<>", "!=");    // allow use of <> as synonym for NE (!=)
              //newVHs = TAGFunctions.toValidXMLString(newVHs, false);
              aOld.InnerXml = newVHs;
            }
          }
        }
      }
      string newXML = myXMLDoc.OuterXml.ToString();
      return newXML;

    }

    /// <summary>
    /// Creates an abreviated version of the Item in Json format. This does not have itemhistory or valuehistory, or all of the 
    /// properties of the item. It just creates jason of the id, description, and attribute name/value pairs
    /// </summary>
    /// <returns></returns>
    public string ToJson()
    {
      StringBuilder s = new StringBuilder();
      s.Append("\"item\": { \"id\": \"");
      s.Append(ID);
      s.Append("\", \"description\": \"");
      s.Append(Description);
      s.Append("\", \"attributes\": {");
      foreach (TAGAttribute a in Attributes)
        s.Append(string.Format("\"{0}\": \"{1}\",",a.ID, TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.CString, a.Value)));
      if (Count > 0)
        s.Length = s.Length - 1; // string off the final comma
      s.Append("} }");
      return s.ToString();
    }

    public void loadJson(string json)
    {
      if (json.StartsWith("{"))
        json = (string)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.stripParens, json);
      string insidestring = "\"" + CommonFunctions.getJsonValue(json) + "\"";
      string[] tokens = CommonFunctions.parseString(insidestring);
      if (tokens != null && tokens.GetLength(0) == 3)
      {      
        ID = CommonFunctions.getJsonValue(tokens[0]);
        Description = CommonFunctions.getJsonValue(tokens[1]);
        string attributeList = "\"" + CommonFunctions.getJsonValue(tokens[2]) + "\"";
        attributeList = (string)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.stripParens, attributeList); // and string the braces
        tokens = (string[])TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.parseString, attributeList);
        for (int i = 0; i < tokens.GetLength(0); i++)
        {
          string[] parts = tokens[i].Split(new char[] { ':' });
          if (parts != null && parts.GetLength(0) == 2)
          {
            TAGAttribute a = new TAGAttribute();
            string id = string.Empty;
            if (parts[0].Length > 2)
              id = parts[0].Substring(1, parts[0].Length - 2);
            string val = string.Empty;
            string testVal = parts[1].Trim();
            if (testVal.Length >= 2)
              val = testVal.Trim().Substring(1, testVal.Length - 2);
            if (!string.IsNullOrEmpty(id))
            {
              a.ID = id;
              a.Value = val;
              Add(a);
            }
          }
        }
      }

    }

    /// <summary>
    /// Converts the current list of attributes and values into AttributeTable format;
    /// </summary>
    /// <returns>AttributeTable format string with list of Attributes and their values. Note this is with a header</returns>
    public string ToAttributeTable()
    {      
      int j = 0;

      string[] headerList = new string[] { "Name", "Value" };
      PickList attributeList = new PickList(headerList, this.Attributes.Count);

      Item i = (Item)this.Clone();
      i.Attributes.Sort();                               // Ensures that the attributes are in alphabetical order
      foreach (TAGAttribute a in i.Attributes)
      {
        attributeList[j, 0] = a.ID;
        attributeList[j, 1] = (string)TAGFunctions.evaluateFunction(TAGFunctions.EnumFunctions.CString, a.Value);
        j++;
      }
      string attributeTable = attributeList.ToString();
      return attributeTable;
    }

    #endregion public methods

    #region private methods
    private void removeValueTypeAttribute(TAGAttribute a)
    {
      string compareValueType = a.ValueType.ToLower();
      if (valueTypeIndex.ContainsKey(compareValueType))
      {
        if (valueTypeIndex[compareValueType].ContainsKey(a.ID))
        {
          valueTypeIndex[compareValueType].Remove(a.ID);
          if (valueTypeIndex[compareValueType].Count == 0)
            valueTypeIndex.Remove(compareValueType);
        }
      }
    }
    private void addValueTypeAttribute(TAGAttribute a)
    {
      string compareValueType = a.ValueType.ToLower();
      if (!valueTypeIndex.ContainsKey(compareValueType))
      {
        SortedDictionary<string, TAGAttribute> newEntry = new SortedDictionary<string, TAGAttribute>();
        newEntry.Add(a.ID, a);
        valueTypeIndex.Add(compareValueType, newEntry);
      }
      else
        if (valueTypeIndex[compareValueType].ContainsKey(a.ID))
          valueTypeIndex[compareValueType][a.ID] = a;
        else
          valueTypeIndex[compareValueType].Add(a.ID, a);
    }
    #endregion
  }
}
